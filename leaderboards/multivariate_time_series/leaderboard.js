LOADIGN = false
METHOD = {
    "PatchTST": {
      "paper-url": "https://openreview.net/forum?id=Jbdc0vTOcol",
      "publication": "ICLR",
      "bib": "https://dblp.org/rec/conf/iclr/NieNSK23.html?view=bibtex",
      "year": "2023"
    },
    "Crossformer": {
      "paper-url": "https://openreview.net/forum?id=vSVLM2j9eie",
      "publication": "ICLR",
      "bib": "https://dblp.org/rec/conf/iclr/ZhangY23.html?view=bibtex",
      "year": "2023"
    },
    "FEDformer": {
      "paper-url": "https://proceedings.mlr.press/v162/zhou22g.html",
      "publication": "ICML",
      "bib": "https://dblp.org/rec/conf/icml/ZhouMWW0022.html?view=bibtex",
      "year": "2022"
    },
    "Informer": {
      "paper-url": "https://ojs.aaai.org/index.php/AAAI/article/view/17325",
      "publication": "AAAI",
      "bib": "https://dblp.org/rec/conf/aaai/ZhouZPZLXZ21.html?view=bibtex",
      "year": "2021"
    },
    "Triformer": {
      "paper-url": "https://arxiv.org/pdf/2204.13767",
      "publication": "IJCAI",
      "bib": "https://dblp.org/rec/conf/ijcai/CirsteaG0KDP22.html?view=bibtex",
      "year": "2022"
    },
    "DLinear": {
      "paper-url": "https://ojs.aaai.org/index.php/AAAI/article/view/26317",
      "publication": "AAAI",
      "bib": "https://dblp.org/rec/conf/aaai/ZengCZ023.html?view=bibtex",
      "year": "2023"
    },
    "NLinear": {
      "paper-url": "https://ojs.aaai.org/index.php/AAAI/article/view/26317",
      "publication": "AAAI",
      "bib": "https://dblp.org/rec/conf/aaai/ZengCZ023.html?view=bibtex",
      "year": "2023"
    },
    "MICN": {
      "paper-url": "https://openreview.net/forum?id=zt53IDUR1U",
      "publication": "ICLR",
      "bib": "https://dblp.org/rec/conf/iclr/Wang0HWCX23.html?view=bibtex",
      "year": "2022"
    },
    "TimesNet": {
      "paper-url": "https://arxiv.org/pdf/2210.02186v2/1000",
      "publication": "ICLR",
      "bib": "https://dblp.org/rec/conf/iclr/WuHLZ0L23.html?view=bibtex",
      "year": "2023"
    },
    "TCN": {
      "paper-url": "https://arxiv.org/pdf/1803.01271",
      "publication": "arXiv",
      "bib": "https://dblp.org/rec/journals/corr/abs-1803-01271.html?view=bibtex",
      "year": "2018"
    },
    "FiLM": {
      "paper-url": "https://openreview.net/forum?id=zTQdHSQUQWc",
      "publication": "NeurIPS",
      "bib": "https://dblp.org/rec/conf/nips/ZhouMWW0YY022.html?view=bibtex",
      "year": "2022"
    },
    "RNN": {
      "paper-url": "https://proceedings.mlr.press/v89/gasthaus19a.html",
      "publication": "arXiv",
      "bib": "https://proceedings.mlr.press/v89/gasthaus19a.html",
      "year": "2019"
    },
    "Linear Regression": {
      "paper-url": "https://books.google.com/books?hl=zh-CN&lr=&id=8r0qE35wt44C&oi=fnd&pg=PR5&dq=Regression+models+for+time+series+analysis&ots=vd653g9LXv&sig=JPr8C-hETsPfWyuxTUlWgL0eKDA",
      "publication": "Wiley",
      "bib": "https://books.google.com/books?hl=zh-CN&lr=&id=8r0qE35wt44C&oi=fnd&pg=PR5&dq=Regression+models+for+time+series+analysis&ots=vd653g9LXv&sig=JPr8C-hETsPfWyuxTUlWgL0eKDA",
      "year": "2005"
    },
    "VAR": {
      "paper-url": "https://www.tandfonline.com/doi/abs/10.1080/07474939408800286",
      "publication": "Economet Rev",
      "bib": "https://www.tandfonline.com/doi/abs/10.1080/07474939408800286",
      "year": "1994"
    },
    "iTransformer": {
      "paper-url": "https://arxiv.org/pdf/2310.06625",
      "publication": "ICLR",
      "bib": "https://dblp.org/rec/journals/corr/abs-2310-06625.html?view=bibtex",
      "year": "2024"
    },
    "FITS": {
      "paper-url": "[2307.03756] FITS: Modeling Time Series with $10k$ Parameters",
      "publication": "ICLR",
      "bib": "https://dblp.org/rec/journals/corr/abs-2307-03756.html?view=bibtex",
      "year": "2024"
    },
    "TimeMixer": {
      "paper-url": "https://arxiv.org/pdf/2405.14616",
      "publication": "ICLR",
      "bib": "https://dblp.org/rec/journals/corr/abs-2405-14616.html?view=bibtex",
      "year": "2024"
    },
    "Non-stationary Transformer": {
      "paper-url": "https://arxiv.org/pdf/2205.14415",
      "publication": "NeurIPS",
      "bib": "https://dblp.org/rec/conf/nips/LiuWWL22.html?view=bibtex",
      "year": "2022"
    },
    "Pathformer": {
      "paper-url": "https://arxiv.org/pdf/2402.05956",
      "publication": "ICLR",
      "bib": "https://dblp.org/rec/journals/corr/abs-2402-05956.html?view=bibtex",
      "year": "2024"
    },
    "DUET": {
      "paper-url": "https://arxiv.org/pdf/2412.10859",
      "publication": "KDD",
      "bib": "",
      "year": "2025"
    },
    "PDF": {
      "paper-url": "https://openreview.net/forum?id=dp27P5HBBt",
      "publication": "ICLR",
      "bib": "https://dblp.uni-trier.de/rec/conf/iclr/0001WLLB0X24.html?view=bibtex",
      "year": "2024"
    }
  }

const DATASET = {
      "Electricity": [
        "ETTh1",
        "ETTh2",
        "ETTm1",
        "ETTm2",
        "Electricity"
      ],
      "Traffic": [
        "Traffic",
        "PEMS-BAY",
        "METR-LA",
        "PEMS04",
        "PEMS08"
      ],
      "Environment": [
        "Weather",
        "AQShunyi",
        "AQWan"
      ],
      "Economic": [
        "Exchange",
        "FRED-MD"
      ],
      "Health": [
        "ILI",
        "Covid-19"
      ],
      "Energy": [
        "Solar",
        "Wind"
      ],
      "Nature": [
        "ZafNoo",
        "CzeLan"
      ],
      "Stock": [
        "NASDAQ",
        "NYSE"
      ],
      "Banking": [
        "NN5"
      ],
      "Web": [
        "Wike2000"
      ]
    }


// const METRICS =  ['MAE','MAE_DENORM','MAPE','MAPE_DENORM','MSE','MSE_DENORM','MSMAPE','MSMAPE_DENORM','RMSE','RMSE_DENORM','SMAPE','SMAPE_DENORM','WAPE','WAPE_DENORM']
const METRICS =  ['MAE','MAPE','MSE','MSMAPE','RMSE','SMAPE','WAPE']

function displayResults(rankCounts,table,is_rank) {

    const tableBody = document.getElementById(table).getElementsByTagName('tbody')[0];
    tableBody.innerHTML = ''; // Clear existing table body
    
    rankCounts.sort((a, b) => {
        // 优先比较 rank4，降序排列
        if (b['rank4'] !== a['rank4']) {
          return b['rank4'] - a['rank4'];
        }

        // 如果 rank4 相同，比较 rank1，降序排列
        if (b['rank1'] !== a['rank1']) {
          return b['rank1'] - a['rank1'];
        }

        // 如果 rank1 也相同，比较 rank2，降序排列
        if (b['rank2'] !== a['rank2']) {
          return b['rank2'] - a['rank2'];
        }

        // 如果 rank2 也相同，比较 rank3，降序排列
        return b['rank3'] - a['rank3'];
      });
    
    var total = 0
    rankCounts.forEach(( counts, index) => {
        
        model = counts['model']
        total += counts['rank1']
        if (!is_rank)
        {
            index=''
        }else
        {
          index=index+1
        }
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${index}</td>
            <td>${model}</td>
            <td>${counts['rank4']}</td>
            <td>${counts['rank1']}</td>
            <td>${counts['rank2']}</td>
            <td>${counts['rank3']}</td>
            <td>
                <a href="${METHOD[model]['paper-url']}"  target="_blank">paper</a>
            </td>
            <td>
             ${METHOD[model]['publication']} [<a href="${METHOD[model]['bib']}" target="_blank">bib</a>]
            </td>
            <td>
                ${METHOD[model]['year']}
            </td>
        `;
        tableBody.appendChild(row);
    });
}
var READY=false

function phraseMultiTable(table, datasets,select_metrics,select_horizons,select_score) {

        
        if (select_metrics.length==0||select_horizons==0||datasets==0)
        {
          const modelKeys = Object.keys(METHOD);

        // 3. 对 key 数组进行排序
        modelKeys.sort((keyA, keyB) => {
            // 从原始数据中获取两个 key 对应的年份
            // 使用 parseInt 将年份字符串转换为数字，以便正确比较
            const yearA = parseInt(METHOD[keyA].year);
            const yearB = parseInt(METHOD[keyB].year);
            
            // 返回 yearB - yearA 实现降序排序（从新到旧）
            // 如果想要升序（从旧到新），则返回 yearA - yearB
            return yearB - yearA;
        });
          var final_result=[]
            // loading.style = 'display:none;'
            modelKeys.forEach(data_obj=>{
            final_result.push({'model':data_obj,'rank1':0,'rank2':0,'rank3':0,
            'rank4':0})
        })
        console.log(final_result)
          displayResults(final_result, table,false);
        }
        else
        {const url = 'http://120.77.11.87:3333/rank';
        const body = {
                    "metrics": select_metrics,
                    "datasets": datasets,
                    "models": ["PatchTST","Crossformer","FEDformer","Informer","Triformer","DLinear","NLinear","MICN","TimesNet","TCN","FiLM","RNN","Linear Regression","VAR","iTransformer","FITS","TimeMixer","Non-stationary Transformer","Pathformer","DUET","PDF"],
                    "pred_len": select_horizons,
                }
        var weight=[]
        if (select_score[0]=='1')
        {
            weight=[1,0,0]
        }
        else if(select_score[0]=='2')
        {
            weight=[1,1,1]
        }else if(select_score[0]=='3')
        {   
            var socre31 =  document.getElementById('score/3/1');
            var socre32 =  document.getElementById('score/3/2');
            var socre33 =  document.getElementById('score/3/3');
            var v1=0,v2=0,v3=0
            if (socre31.value)
            {
                v1 =  parseFloat(socre31.value)
            }
            if (socre32.value)
            {
                v2 = parseFloat(socre32.value)
            }
            if (socre33.value)
            {
                v3 =  parseFloat(socre33.value)
            }
            weight=[v1,v2,v3]
        }

        // const loading = document.getElementById('loading');
        // loading.style = 'display:table-row;'
        fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body)
        })
        .then(response => {
          console.log(response)
          // 1. 首先检查响应状态
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          // 2. 正确解析JSON响应
          return response.json();
        })
        .then(data => {
    
            var final_result=[]
            // loading.style = 'display:none;'
            data.forEach(data_obj=>{
              key = Object.keys(data_obj)[0]
            final_result.push({'model':key,'rank1':data_obj[key][0],'rank2':data_obj[key][1],'rank3':data_obj[key][2],
            'rank4':parseFloat(data_obj[key][0]*weight[0]+data_obj[key][1]*weight[1]+data_obj[key][2]*weight[2]).toFixed(0)})
        })
          console.log(final_result)
          displayResults(final_result, table,true);
        })
        .catch(error => {
          // 4. 添加错误处理
          console.error('请求失败:', error);
        });
      }

}

function calScore()
{
      // Identify model columns
      const modelColumns = Object.keys(filteredExperimentData[0]).slice(1);
      const rankCounts = {};
      modelColumns.forEach(model => {
          rankCounts[model] = {1: 0, 2: 0, 3: 0, 4: 0};
      });
      
      var socre31 =  document.getElementById('score/3/1');
      var socre32 =  document.getElementById('score/3/2');
      var socre33 =  document.getElementById('score/3/3');
      var v1=0,v2=0,v3=0
      if (socre31.value)
      {
          v1 =  parseFloat(socre31.value)
      }
      if (socre32.value)
      {
          v2 = parseFloat(socre32.value)
      }
      if (socre33.value)
      {
          v3 =  parseFloat(socre33.value)
      }
      // Process filtered experiment data
      filteredExperimentData.forEach(row => {
  
          const validModels = modelColumns.filter(model => !isNaN(row[model]));
          validModels.sort((a, b) => row[a] - row[b]);
          minValue = Infinity
          secondMinValue = Infinity
          thirdMinValue = Infinity
          validModels.forEach(model => {
          const value = row[model];
          if(typeof value === 'number')
          {
            if (value < minValue) {
            // 更新第三小值、第二小值和最小值
            [thirdMinValue, secondMinValue, minValue] = [secondMinValue, minValue, value];
            } else if (value < secondMinValue && value !== minValue) {
                // 更新第三小值和第二小值
                [thirdMinValue, secondMinValue] = [secondMinValue, value];
            } else if (value < thirdMinValue && value !== minValue && value !== secondMinValue) {
                // 更新第三小值
                thirdMinValue = value;
            }
          }
          });
       
          // 最后对每个模型的对应排名做计数加一
          validModels.forEach(model => {
              if (row[model]== minValue)
              {
                  rank = 1;
                  rankCounts[model][rank] = (rankCounts[model][rank] || 0) + 1;
              }else if(row[model]== secondMinValue)
              {
                  rank = 2;
                  rankCounts[model][rank] = (rankCounts[model][rank] || 0) + 1;
              }else if(row[model]== thirdMinValue)
              {
                  rank = 3;
                  rankCounts[model][rank] = (rankCounts[model][rank] || 0) + 1;
              }
          });
          validModels.forEach(model => {
              if (select_score[0] == '1' )
              {
                  rankCounts[model][4] = rankCounts[model][1];
              }
              else if (select_score[0] == '2' )
              {
                  rankCounts[model][4] = rankCounts[model][1] + rankCounts[model][2] + rankCounts[model][3];
              }
              else if (select_score[0] == '3' )
              {
                  rankCounts[model][4] = parseFloat(( v1* rankCounts[model][1] + v2 * rankCounts[model][2] + v3* rankCounts[model][3]).toFixed(2))
              }
              
          });
      });
  
  
      Object.entries(rankCounts).forEach(([model, values]) => {
          result.push({"model": model, 'rank1': values['1'], 'rank2': values['2'], 'rank3': values['3'], 'rank4': values['4']});
      });
}
function populateCheckboxes() {
    const container = document.getElementById('dataset-container-mul');
    const groupedDatasets = DATASET;
    const list = document.getElementById('Metrics')
    // groupedDatasets['Metrics'] = METRICS;
    groupedDatasets['Normalized'] = METRICS;
    groupedDatasets['Denormalized'] = METRICS;
    const sortedCategories = Object.keys(groupedDatasets).sort((a, b) => groupedDatasets[b].length - groupedDatasets[a].length);
    
    sortedCategories.forEach(category => {
        const categoryDiv = document.createElement('div');

        categoryDiv.className = 'category';
        categoryDiv.value = category;
        const categoryLabel = document.createElement('h3');
        const categoryCheckbox = document.createElement('input');
        categoryCheckbox.type = 'checkbox';
        categoryCheckbox.id = `select-all-${category}`;
        categoryCheckbox.addEventListener('change', () => toggleCategory(category, categoryCheckbox.checked));
    
        categoryLabel.appendChild(categoryCheckbox);
        categoryLabel.appendChild(document.createTextNode(` ${category}`));
        categoryDiv.appendChild(categoryLabel);
    
        const d = document.createElement('div');
        if (category == 'Normalized'||category == 'Denormalized') {
            // d.className = 'checkbox-wrapper1';
        }
        groupedDatasets[category].forEach(name => {
            name = name.replace('_', '-');
            const div = document.createElement('div');
            div.className = 'checkbox-item';
    
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `${category}/${name}`;
            checkbox.value = `${category}/${name}`;
            checkbox.className = `checkbox-${category}`;
            checkbox.addEventListener('change', handleChildCheckboxChange);
    
            const label = document.createElement('label');
            label.htmlFor = `${category}/${name}`;
            label.textContent = name;
    
            div.appendChild(checkbox);
            div.appendChild(label);
            d.appendChild(div);
            categoryDiv.appendChild(d);
        });
        if (category == 'Normalized'||category == 'Denormalized') {
          list.appendChild(categoryDiv);
        }else{
          container.appendChild(categoryDiv);
        }

    });
    
  //   ["Norm"].forEach(metric => {
  //     category='Normalized'
  //     const categoryDiv = document.createElement('div');
  //     categoryDiv.className = 'category';
  
  //     const categoryLabel = document.createElement('h3');
  //     const categoryCheckbox = document.createElement('input');
  //     categoryCheckbox.type = 'checkbox';
  //     categoryCheckbox.id = `select-all-${category}`;
  //     categoryCheckbox.addEventListener('change', () => toggleCategory(category, categoryCheckbox.checked));
  
  //     categoryLabel.appendChild(categoryCheckbox);
  //     categoryLabel.appendChild(document.createTextNode(` ${category}`));
  //     categoryDiv.appendChild(categoryLabel);
  
  //     const d = document.createElement('div');
  //     if (category == 'Metrics') {
  //         d.className = 'checkbox-wrapper1';
  //     }
  //     groupedDatasets[category].forEach(name => {
  //         name = name.replace('_', '-');
  //         const div = document.createElement('div');
  //         div.className = 'checkbox-item';
  
  //         const checkbox = document.createElement('input');
  //         checkbox.type = 'checkbox';
  //         checkbox.id = `${category}/${name}`;
  //         checkbox.value = `${category}/${name}`;
  //         checkbox.className = `checkbox-${category}`;
  //         checkbox.addEventListener('change', handleChildCheckboxChange);
  
  //         const label = document.createElement('label');
  //         label.htmlFor = `${category}/${name}`;
  //         label.textContent = name;
  
  //         div.appendChild(checkbox);
  //         div.appendChild(label);
  //         d.appendChild(div);
  //         categoryDiv.appendChild(d);
  //     });
  //     list.appendChild(categoryDiv);

  // });

    // METRICS.forEach(metric => {
    //     const div = document.createElement('div');
    //     div.className = 'checkbox-item';
    //     const label = document.createElement('label');
    //     label.for = 'Metrics/MAE'
    //     label.innerHTML = metric
    //     // <input type="checkbox" id="Metrics/MAE" value="Metrics/MAE" onchange="handleChildCheckboxChange(event)" class="checkbox-Metrics">
        
    //     const categoryCheckbox = document.createElement('input');
    //     categoryCheckbox.type = 'checkbox';
    //     categoryCheckbox.id = `Metrics/${metric}`;
    //     categoryCheckbox.value=`Metrics/${metric}`;
    //     categoryCheckbox.className = 'checkbox-Metrics';
    //     if(metric.includes('_'))
    //     {
    //         div.style="margin-left:0"
    //     }
    //     categoryCheckbox.addEventListener('change', (event) => handleChildCheckboxChange(event));
       

    //     div.appendChild(categoryCheckbox);
    //     div.appendChild(label)
    //     list.appendChild(div)
    // });


}

function updateP1checkbox()
{
    checked=true

    p1_dataset=['Traffic/Traffic', 'Energy/Solar','Health/ILI','select-all-Electricity','Environment/Weather','Economic/Exchange']
    
    p1_dataset.forEach(checkbox_id=>{
        var check_box = document.getElementById(checkbox_id)
        if(!check_box.checked)
        {
            checked=false
        }
    })
    category = 'Electricity'
    const checkboxes = document.querySelectorAll(`.checkbox-${category}`);
    checkboxes.forEach(checkbox => {
        if(!checkbox.checked)
        {
            checked=false
        }
    });
    
    check_box = document.getElementById('select-p1')
    check_box.checked = checked


}

function toggleCategory(category, isChecked) {
    if (category=='Metrics')
    {
      var checkbox = document.getElementById('select-all-' + category);
      checkbox.checked = isChecked;
      checkbox = document.getElementById('select-all-' + "Normalized");
      checkbox.checked = isChecked;
      checkbox = document.getElementById('select-all-' + "Denormalized");
      checkbox.checked = isChecked;
      const checkboxes1 = document.querySelectorAll(`.checkbox-Normalized`);
      const checkboxes2 = document.querySelectorAll(`.checkbox-Denormalized`);
      checkboxes1.forEach(checkbox => {
          checkbox.checked = isChecked;
      });
      checkboxes2.forEach(checkbox => {
        checkbox.checked = isChecked;
    });
    }
    else
    {
      const checkbox = document.getElementById('select-all-' + category);
      checkbox.checked = isChecked;
      const checkboxes = document.querySelectorAll(`.checkbox-${category}`);
      checkboxes.forEach(checkbox => {
          checkbox.checked = isChecked;
      });
    }


    submitSelection();  
}

function submitSelection() {
    if (!READY)
    {
        return
    }
    const selectedDatasets = [];
    const checkboxes = document.querySelectorAll('.checkbox-container input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
        if (checkbox.checked) {
            if (checkbox.value.includes('/'))
            {
                selectedDatasets.push(checkbox.value.split('/')[1].replace('-','_'));     
            }
            
        }
    });

    select_metrics = []
    const checkboxes_norm = document.querySelectorAll('.checkbox-Normalized');
    checkboxes_norm.forEach(checkbox => {
        if (checkbox.checked) {
            items = checkbox.value.split('/')
            if (items.length == 2) {
                select_metrics.push(items[1])
            }
        }
    }); 
    const checkboxes_denorm = document.querySelectorAll('.checkbox-Denormalized');
    checkboxes_denorm.forEach(checkbox => {
        if (checkbox.checked) {
            items = checkbox.value.split('/')
            if (items.length == 2) {
                select_metrics.push(items[1]+"_Denorm")
            }
        }
    }); 
    select_horizons = []
    const checkboxes2 = document.querySelectorAll('#dataset-container-mul-down input[type="checkbox"]');
    checkboxes2.forEach(checkbox => {
        if (checkbox.checked) {
            items = checkbox.value.split('/')
            if (items.length == 2) {
                select_horizons.push(items[1])
            }
        }
    });
    
    select_score = []
    const checkboxes3 = document.querySelectorAll('#dataset-container-mul-down1 input[type="radio"]');
    checkboxes3.forEach(checkbox => {
        if (checkbox.checked) {
            items = checkbox.value.split('/')
            if (items.length == 2) {
                select_score.push(items[1])
            }
        }
    });
    
    phraseMultiTable('multivariateTable2', selectedDatasets, select_metrics, select_horizons, select_score)
}

function updateParentCheckbox(category) {
    const checkboxes = document.querySelectorAll(`.checkbox-${category}`);
    const allChecked = Array.from(checkboxes).every(checkbox => checkbox.checked);
    document.getElementById(`select-all-${category}`).checked = allChecked;
}

function handleChildCheckboxChange(event) {
    const checkbox = event.target;
    const category = checkbox.className.split('-')[1];
    if (category == 'Score')
    {
        checkbox.checked = true
        var id = checkbox.value
        for (let i1 = 1; i1 < 4; i1++) {
            const scoreBox = document.getElementById(`Score/${i1}`);
            if (scoreBox.value!=id) {
                scoreBox.checked = false;
            }
        }
    }
    else{
      updateParentCheckbox(category);
    }
    submitSelection();
}

function toggleSelectAll(selectAllCheckbox) {
    const container = document.getElementById('all');
    const checkboxes = container.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
        checkbox.checked = selectAllCheckbox;
    });
    submitSelection(); // 调用submitSelection来处理选中的数据
}

function p1(checked)
{
    toggleSelectAll(false)
    p1_dataset=['Traffic/Traffic', 'Energy/Solar','Health/ILI','select-all-Electricity','Environment/Weather','Economic/Exchange']

    p1_dataset.forEach(checkbox_id=>{
        var check_box = document.getElementById(checkbox_id)
        check_box.checked = checked;
    })
    toggleCategory('Electricity', checked) 
    submitSelection()
}

function setContainerHeight() {
    // const tableContainer = document.querySelector('#table-container1');
    // const mainContainer = document.querySelector('#main-container1');
    // mainContainer.style.height = tableContainer.offsetHeight + 'px';

    // const tableContainer = document.querySelector('#table-container1');
    // const mainContainer = document.querySelector('#main-container1');
    // mainContainer.style.height = tableContainer.offsetHeight + 'px';
}

let lastValidValue = '';
function validateInput(input) {
    let value = input.value;

    // 保存光标位置
    const cursorPos = input.selectionStart;
    
    // 处理整数和小数部分
    let [integerPart, decimalPart] = value.split('.');
    

    // 处理整数部分：去除前导零并限制最大两位数
    
    // 去除前导零
    if (integerPart.length > 1) {
        integerPart = integerPart.replace(/^0+/, ''); 
    }
    
    // 处理小数部分：限制最多两位
    if (decimalPart) {
        decimalPart = decimalPart.slice(0, 2);
    }
    
    // 合并整数部分和小数部分
    let newValue = integerPart;
    if (decimalPart) {
        newValue += '.' + decimalPart;
    }
    
    // 如果小数点后有数字，但是小数点前的数字部分为空，应至少显示 `0`
    if (newValue === '' || newValue === '.') {
        newValue = '0';
    }
    
    // 验证并更新输入值
    if (newValue !== value) {
        input.value = newValue;
    }
    
    // 更新最后一个有效值
    lastValidValue = input.value;
    
    // 恢复光标的位置
    // input.setSelectionRange(cursorPos, cursorPos);
    submitSelection()
}

function findBottomThreeKeys(obj) {
    let minKey = null;
    let secondMinKey = null;
    let thirdMinKey = null;
    let minValue = Infinity;
    let secondMinValue = Infinity;
    let thirdMinValue = Infinity;

    for (const [key, value] of Object.entries(obj)) {
        if (typeof value === 'number') {
            if (value < minValue) {
                // 更新第三小值和键
                thirdMinValue = secondMinValue;
                // 更新第二小值和键
                secondMinValue = minValue;
                // 更新最小值和键
                minValue = value;

            } else if (value < secondMinValue && value!=minValue) {
                // 更新第三小值和键
                thirdMinValue = secondMinValue;
                // 更新第二小值和键
                secondMinValue = value;

            } else if (value < thirdMinValue&& value!=minValue&& value!=secondMinValue) {
                // 更新第三小值和键
                thirdMinValue = value;
            }
        }
    }

    return {
        minValue,
        secondMinValue,
        thirdMinValue,
    };
}
function format(num)
{
  if (typeof(num)!='number')
  {
    return 'NaN'
  }else
  {
    return num.toFixed(3)
  }
}


function start()
{   
    populateCheckboxes()
    const selectAllCheckbox = document.getElementById('select-all');
    if (selectAllCheckbox) {
    selectAllCheckbox.checked = true;
    toggleSelectAll(selectAllCheckbox.checked); // Ensure all individual checkboxes are also checked
    }
    document.getElementById(`Score/1`).checked = false
    document.getElementById(`Score/2`).checked = true
    document.getElementById(`Score/3`).checked = false
    setContainerHeight()
    toggleCategory('Metrics',true)
    toggleCategory('Horizons',true)
    READY = true
    submitSelection()
   
}
